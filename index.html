<html>
  <head>
    <!-- Pull the engine from the Quintus CDN or load it locally -->
    <!-- (use quintus-all.min.js for production) -->
    <script src='http://cdn.html5quintus.com/v0.1.5/quintus-all.js'></script>
    <!-- <script src='quintus-all.js'></script> -->
  </head>
   <body>
     <script>
     
      // Now set up your game (most games will load a separate .js file)
      var Q = Quintus({ development: true })                          // Create a new engine instance
              .include("Sprites, Scenes, Input, 2D, Touch, UI") // Load any needed modules

      Q.setup()                           // Add a canvas element onto the page
       .controls()                        // Add in default controls (keyboard, buttons)
       .touch(Q.SPRITE_ALL);                          // Add in touch support (for the UI)
              

      Q.Sprite.extend("Block", {
        init: function(p) {
          this._super(p, {
            scale: 1,
            sheet: "blocks",
            frame: 0,
            gravity: 0,
            vy: 40
          });
          this.add("2d");
          this.on("touch",function(touch) {
            // how to trigger something on my stage?
            this.stage.trigger("swap",this);
            console.log(touch.x,touch.y,this.p);
          });
        }
      });

      Q.Sprite.extend("UIPull", {
        init: function(p) {
          this._super(p, {
            sheet: "blocks",
            frame: 6,
            gravity: 0,
            type: Q.SPRITE_UI
          });
          this.on("touch",function(touch) {
            console.log("pull?");
            Q.stage(1).trigger("pull");
          });
        }
      });

      Q.Sprite.extend("Fallthrough", {
        init: function(p) {
          this._super(p,{
            w: 5*32,
            h: 6*32,
          });
          this.on("touch",function(touch) {
            console.log("fallthrough touched");
            x = Math.floor((touch.x)/32)*32+16;
            Q.stage(1).trigger("place",{x:x,y:touch.y});
          });
        },
        draw: function(ctx) {
          ctx.strokeStyle = "red";
          ctx.strokeRect(-this.p.cx,-this.p.cy,this.p.w,this.p.h);
        }
      });

      Q.scene("fallthrough", function(stage) {
        var fallthrough = stage.insert(new Q.Fallthrough({x: 3*32+16, y: 4*32}));
      });

      Q.scene("ui", function(stage) {
        stage.insert(new Q.UIPull({x: (32*1)+16, y:(32*9)+16}));
      });

      Q.scene("level1", function(stage) {

        /*
        var block = stage.insert(new Q.Block({x: (32*1)+16, y: (32+16), frame: 0}));
        var block2 = stage.insert(new Q.Block({x: (32*2)+16, y: (32+16), frame: 1}));
        var block3 = stage.insert(new Q.Block({x: (32*3)+16, y: (32+16), frame: 2}));
        var block4 = stage.insert(new Q.Block({x: (32*4)+16, y: (32+16), frame: 3}));
        var block5 = stage.insert(new Q.Block({x: (32*5)+16, y: (32+16), frame: 4}));
        */


        Q.state.set("hand",null);

        tileLayer = new Q.TileLayer({
          tileW: 8*4,
          tileH: 8*4,
          sheet: "border",
          dataAsset: "border.json"
        });

        stage.collisionLayer(tileLayer);


        stage.on("swap",function(block) {
          console.log("swap",block);
          hand = Q.state.get("hand")
          if(hand!=block) {
            if(hand==null) {
              block.p.x = 3*32+16;
              block.p.y = 7*32+16;
              block.p.vy = 0;
              Q.state.set("hand",block);
            } else {
              hand.p.x = block.p.x;
              hand.p.y = block.p.y;
              hand.p.vy = block.p.vy;
              block.p.x = 3*32+16;
              block.p.y = 7*32+16;
              block.p.vy = 0;
              Q.state.set("hand",block);
            }
          }
          stage.each(function(){if(this instanceof Q.Block){this.p.vy=40}});
        });

        stage.on("place",function(touch) {
          console.log("place",touch);
          hand = Q.state.get("hand")
          if(hand!=null) {
            hand.p.x = touch.x;
            // slightly (but not completely) mitigate pushing blocks through the bottom of the level
            obs = Q.stage(1).detect(function(){return (this.p.y-32)<touch.y && this.p.y>touch.y});
            console.log(obs);
            if(obs) {
              touch.y = obs.p.y-32;
            }
            hand.p.y = touch.y;
            hand.p.vy = 40;
            Q.state.set("hand",null);
          }
        });

        stage.on("pull",function(){
          for(i=0;i<5;i++) {
            stage.insert(new Q.Block({x: (32*(i+1))+16, y: (32+16), frame: Math.floor(Math.random()*6)}));
          }
        });

        stage.trigger("pull");
      });

      Q.load("blocks8x8x4.png, border.json", function() {

        Q.sheet("blocks", "blocks8x8x4.png",
                {
                  tilew: 8*4,
                  tileh: 8*4,
                  sx: 0,
                  sy: 0
                });

        Q.sheet("border", "blocks8x8x4.png",
                {
                  tilew: 8*4,
                  tileh: 8*4,
                  sx: 0,
                  sy: 2*8*4 
                });

                       
        Q.stageScene("fallthrough",0);
        stage = Q.stageScene("level1",1);
        stage = Q.stageScene("ui",2);

      });
   </script>
   </body>
</html>
